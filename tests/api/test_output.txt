============================= test session starts ==============================
platform darwin -- Python 3.10.6, pytest-7.3.1, pluggy-1.0.0 -- /Users/ninaadkalla/.pyenv/versions/3.10.6/envs/taxifare-env/bin/python3.10
cachedir: .pytest_cache
rootdir: /Users/ninaadkalla/code/ninzyyy/data-fast-api/tests
configfile: pytest_kitt.ini
plugins: asyncio-0.21.0, anyio-3.6.2
asyncio: mode=strict
collecting ... collected 12 items

tests/api/test_cloud_endpoints.py::test_root_is_up FAILED                [  8%]
tests/api/test_cloud_endpoints.py::test_root_returns_greeting PASSED     [ 16%]
tests/api/test_cloud_endpoints.py::test_predict_is_up PASSED             [ 25%]
tests/api/test_cloud_endpoints.py::test_predict_is_dict PASSED           [ 33%]
tests/api/test_cloud_endpoints.py::test_predict_has_key PASSED           [ 41%]
tests/api/test_cloud_endpoints.py::test_cloud_api_predict PASSED         [ 50%]
tests/api/test_endpoints.py::test_root_is_up PASSED                      [ 58%]
tests/api/test_endpoints.py::test_root_returns_greeting PASSED           [ 66%]
tests/api/test_endpoints.py::test_predict_is_up PASSED                   [ 75%]
tests/api/test_endpoints.py::test_predict_is_dict PASSED                 [ 83%]
tests/api/test_endpoints.py::test_predict_has_key PASSED                 [ 91%]
tests/api/test_endpoints.py::test_predict_val_is_float PASSED            [100%]

=================================== FAILURES ===================================
_______________________________ test_root_is_up ________________________________

self = TLSStream(transport_stream=<anyio._backends._asyncio.SocketStream object at 0x128a98640>, standard_compatible=False, _...t at 0x128ad0f70>, _read_bio=<_ssl.MemoryBIO object at 0x128ad1000>, _write_bio=<_ssl.MemoryBIO object at 0x128ad1270>)
func = <bound method SSLObject.read of <ssl.SSLObject object at 0x128ad0f70>>
args = (65536,)

    async def _call_sslobject_method(
        self, func: Callable[..., T_Retval], *args: object
    ) -> T_Retval:
        while True:
            try:
>               result = func(*args)

../../../.pyenv/versions/3.10.6/envs/taxifare-env/lib/python3.10/site-packages/anyio/streams/tls.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <ssl.SSLObject object at 0x128ad0f70>, len = 65536, buffer = None

    def read(self, len=1024, buffer=None):
        """Read up to 'len' bytes from the SSL object and return them.
    
        If 'buffer' is provided, read into this buffer and return the number of
        bytes read.
        """
        if buffer is not None:
            v = self._sslobj.read(len, buffer)
        else:
>           v = self._sslobj.read(len)
E           ssl.SSLWantReadError: The operation did not complete (read) (_ssl.c:2548)

../../../.pyenv/versions/3.10.6/lib/python3.10/ssl.py:917: SSLWantReadError

During handling of the above exception, another exception occurred:

self = <httpcore.backends.asyncio.AsyncIOStream object at 0x128a98e50>
max_bytes = 65536, timeout = 10

    async def read(
        self, max_bytes: int, timeout: typing.Optional[float] = None
    ) -> bytes:
        exc_map = {
            TimeoutError: ReadTimeout,
            anyio.BrokenResourceError: ReadError,
            anyio.ClosedResourceError: ReadError,
        }
        with map_exceptions(exc_map):
            with anyio.fail_after(timeout):
                try:
>                   return await self._stream.receive(max_bytes=max_bytes)

../../../.pyenv/versions/3.10.6/envs/taxifare-env/lib/python3.10/site-packages/httpcore/backends/asyncio.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = TLSStream(transport_stream=<anyio._backends._asyncio.SocketStream object at 0x128a98640>, standard_compatible=False, _...t at 0x128ad0f70>, _read_bio=<_ssl.MemoryBIO object at 0x128ad1000>, _write_bio=<_ssl.MemoryBIO object at 0x128ad1270>)
max_bytes = 65536

    async def receive(self, max_bytes: int = 65536) -> bytes:
>       data = await self._call_sslobject_method(self._ssl_object.read, max_bytes)

../../../.pyenv/versions/3.10.6/envs/taxifare-env/lib/python3.10/site-packages/anyio/streams/tls.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = TLSStream(transport_stream=<anyio._backends._asyncio.SocketStream object at 0x128a98640>, standard_compatible=False, _...t at 0x128ad0f70>, _read_bio=<_ssl.MemoryBIO object at 0x128ad1000>, _write_bio=<_ssl.MemoryBIO object at 0x128ad1270>)
func = <bound method SSLObject.read of <ssl.SSLObject object at 0x128ad0f70>>
args = (65536,)

    async def _call_sslobject_method(
        self, func: Callable[..., T_Retval], *args: object
    ) -> T_Retval:
        while True:
            try:
                result = func(*args)
            except ssl.SSLWantReadError:
                try:
                    # Flush any pending writes first
                    if self._write_bio.pending:
                        await self.transport_stream.send(self._write_bio.read())
    
>                   data = await self.transport_stream.receive()

../../../.pyenv/versions/3.10.6/envs/taxifare-env/lib/python3.10/site-packages/anyio/streams/tls.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <anyio._backends._asyncio.SocketStream object at 0x128a98640>
max_bytes = 65536

    async def receive(self, max_bytes: int = 65536) -> bytes:
        with self._receive_guard:
            await checkpoint()
    
            if (
                not self._protocol.read_event.is_set()
                and not self._transport.is_closing()
            ):
                self._transport.resume_reading()
>               await self._protocol.read_event.wait()

../../../.pyenv/versions/3.10.6/envs/taxifare-env/lib/python3.10/site-packages/anyio/_backends/_asyncio.py:1265: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <asyncio.locks.Event object at 0x128ad10c0 [set]>

    async def wait(self):
        """Block until the internal flag is true.
    
        If the internal flag is true on entry, return True
        immediately.  Otherwise, block until another coroutine calls
        set() to set the flag to true, then return True.
        """
        if self._value:
            return True
    
        fut = self._get_loop().create_future()
        self._waiters.append(fut)
        try:
>           await fut
E           asyncio.exceptions.CancelledError

../../../.pyenv/versions/3.10.6/lib/python3.10/asyncio/locks.py:214: CancelledError

During handling of the above exception, another exception occurred:

map = {<class 'TimeoutError'>: <class 'httpcore.ReadTimeout'>, <class 'anyio.BrokenResourceError'>: <class 'httpcore.ReadError'>, <class 'anyio.ClosedResourceError'>: <class 'httpcore.ReadError'>}

    @contextlib.contextmanager
    def map_exceptions(map: ExceptionMapping) -> Iterator[None]:
        try:
>           yield

../../../.pyenv/versions/3.10.6/envs/taxifare-env/lib/python3.10/site-packages/httpcore/_exceptions.py:10: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <httpcore.backends.asyncio.AsyncIOStream object at 0x128a98e50>
max_bytes = 65536, timeout = 10

    async def read(
        self, max_bytes: int, timeout: typing.Optional[float] = None
    ) -> bytes:
        exc_map = {
            TimeoutError: ReadTimeout,
            anyio.BrokenResourceError: ReadError,
            anyio.ClosedResourceError: ReadError,
        }
        with map_exceptions(exc_map):
>           with anyio.fail_after(timeout):

../../../.pyenv/versions/3.10.6/envs/taxifare-env/lib/python3.10/site-packages/httpcore/backends/asyncio.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <anyio._core._tasks.FailAfterContextManager object at 0x128ad0250>
exc_type = <class 'asyncio.exceptions.CancelledError'>
exc_val = CancelledError(), exc_tb = <traceback object at 0x128af19c0>

    def __exit__(
        self,
        exc_type: Optional[Type[BaseException]],
        exc_val: Optional[BaseException],
        exc_tb: Optional[TracebackType],
    ) -> Optional[bool]:
        retval = self._cancel_scope.__exit__(exc_type, exc_val, exc_tb)
        if self._cancel_scope.cancel_called:
>           raise TimeoutError
E           TimeoutError

../../../.pyenv/versions/3.10.6/envs/taxifare-env/lib/python3.10/site-packages/anyio/_core/_tasks.py:118: TimeoutError

During handling of the above exception, another exception occurred:

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        try:
>           yield

../../../.pyenv/versions/3.10.6/envs/taxifare-env/lib/python3.10/site-packages/httpx/_transports/default.py:60: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <httpx.AsyncHTTPTransport object at 0x128a3fd00>
request = <Request('GET', 'https://taxifare-5t5qkz7wga-nn.a.run.app/')>

    async def handle_async_request(
        self,
        request: Request,
    ) -> Response:
        assert isinstance(request.stream, AsyncByteStream)
    
        req = httpcore.Request(
            method=request.method,
            url=httpcore.URL(
                scheme=request.url.raw_scheme,
                host=request.url.raw_host,
                port=request.url.port,
                target=request.url.raw_path,
            ),
            headers=request.headers.raw,
            content=request.stream,
            extensions=request.extensions,
        )
        with map_httpcore_exceptions():
>           resp = await self._pool.handle_async_request(req)

../../../.pyenv/versions/3.10.6/envs/taxifare-env/lib/python3.10/site-packages/httpx/_transports/default.py:353: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <httpcore.AsyncConnectionPool object at 0x128a980d0>
request = <Request [b'GET']>

    async def handle_async_request(self, request: Request) -> Response:
        """
        Send an HTTP request, and return an HTTP response.
    
        This is the core implementation that is called into by `.request()` or `.stream()`.
        """
        scheme = request.url.scheme.decode()
        if scheme == "":
            raise UnsupportedProtocol(
                "Request URL is missing an 'http://' or 'https://' protocol."
            )
        if scheme not in ("http", "https", "ws", "wss"):
            raise UnsupportedProtocol(
                f"Request URL has an unsupported protocol '{scheme}://'."
            )
    
        status = RequestStatus(request)
    
        async with self._pool_lock:
            self._requests.append(status)
            await self._close_expired_connections()
            await self._attempt_to_acquire_connection(status)
    
        while True:
            timeouts = request.extensions.get("timeout", {})
            timeout = timeouts.get("pool", None)
            try:
                connection = await status.wait_for_connection(timeout=timeout)
            except BaseException as exc:
                # If we timeout here, or if the task is cancelled, then make
                # sure to remove the request from the queue before bubbling
                # up the exception.
                async with self._pool_lock:
                    self._requests.remove(status)
                    raise exc
    
            try:
                response = await connection.handle_async_request(request)
            except ConnectionNotAvailable:
                # The ConnectionNotAvailable exception is a special case, that
                # indicates we need to retry the request on a new connection.
                #
                # The most common case where this can occur is when multiple
                # requests are queued waiting for a single connection, which
                # might end up as an HTTP/2 connection, but which actually ends
                # up as HTTP/1.1.
                async with self._pool_lock:
                    # Maintain our position in the request queue, but reset the
                    # status so that the request becomes queued again.
                    status.unset_connection()
                    await self._attempt_to_acquire_connection(status)
            except BaseException as exc:
                await self.response_closed(status)
>               raise exc

../../../.pyenv/versions/3.10.6/envs/taxifare-env/lib/python3.10/site-packages/httpcore/_async/connection_pool.py:253: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <httpcore.AsyncConnectionPool object at 0x128a980d0>
request = <Request [b'GET']>

    async def handle_async_request(self, request: Request) -> Response:
        """
        Send an HTTP request, and return an HTTP response.
    
        This is the core implementation that is called into by `.request()` or `.stream()`.
        """
        scheme = request.url.scheme.decode()
        if scheme == "":
            raise UnsupportedProtocol(
                "Request URL is missing an 'http://' or 'https://' protocol."
            )
        if scheme not in ("http", "https", "ws", "wss"):
            raise UnsupportedProtocol(
                f"Request URL has an unsupported protocol '{scheme}://'."
            )
    
        status = RequestStatus(request)
    
        async with self._pool_lock:
            self._requests.append(status)
            await self._close_expired_connections()
            await self._attempt_to_acquire_connection(status)
    
        while True:
            timeouts = request.extensions.get("timeout", {})
            timeout = timeouts.get("pool", None)
            try:
                connection = await status.wait_for_connection(timeout=timeout)
            except BaseException as exc:
                # If we timeout here, or if the task is cancelled, then make
                # sure to remove the request from the queue before bubbling
                # up the exception.
                async with self._pool_lock:
                    self._requests.remove(status)
                    raise exc
    
            try:
>               response = await connection.handle_async_request(request)

../../../.pyenv/versions/3.10.6/envs/taxifare-env/lib/python3.10/site-packages/httpcore/_async/connection_pool.py:237: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <AsyncHTTPConnection ['https://taxifare-5t5qkz7wga-nn.a.run.app:443', HTTP/1.1, CLOSED, Request Count: 1]>
request = <Request [b'GET']>

    async def handle_async_request(self, request: Request) -> Response:
        if not self.can_handle_request(request.url.origin):
            raise RuntimeError(
                f"Attempted to send request to {request.url.origin} on connection to {self._origin}"
            )
    
        async with self._request_lock:
            if self._connection is None:
                try:
                    stream = await self._connect(request)
    
                    ssl_object = stream.get_extra_info("ssl_object")
                    http2_negotiated = (
                        ssl_object is not None
                        and ssl_object.selected_alpn_protocol() == "h2"
                    )
                    if http2_negotiated or (self._http2 and not self._http1):
                        from .http2 import AsyncHTTP2Connection
    
                        self._connection = AsyncHTTP2Connection(
                            origin=self._origin,
                            stream=stream,
                            keepalive_expiry=self._keepalive_expiry,
                        )
                    else:
                        self._connection = AsyncHTTP11Connection(
                            origin=self._origin,
                            stream=stream,
                            keepalive_expiry=self._keepalive_expiry,
                        )
                except Exception as exc:
                    self._connect_failed = True
                    raise exc
            elif not self._connection.is_available():
                raise ConnectionNotAvailable()
    
>       return await self._connection.handle_async_request(request)

../../../.pyenv/versions/3.10.6/envs/taxifare-env/lib/python3.10/site-packages/httpcore/_async/connection.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <AsyncHTTP11Connection ['https://taxifare-5t5qkz7wga-nn.a.run.app:443', CLOSED, Request Count: 1]>
request = <Request [b'GET']>

    async def handle_async_request(self, request: Request) -> Response:
        if not self.can_handle_request(request.url.origin):
            raise RuntimeError(
                f"Attempted to send request to {request.url.origin} on connection "
                f"to {self._origin}"
            )
    
        async with self._state_lock:
            if self._state in (HTTPConnectionState.NEW, HTTPConnectionState.IDLE):
                self._request_count += 1
                self._state = HTTPConnectionState.ACTIVE
                self._expire_at = None
            else:
                raise ConnectionNotAvailable()
    
        try:
            kwargs = {"request": request}
            async with Trace("http11.send_request_headers", request, kwargs) as trace:
                await self._send_request_headers(**kwargs)
            async with Trace("http11.send_request_body", request, kwargs) as trace:
                await self._send_request_body(**kwargs)
            async with Trace(
                "http11.receive_response_headers", request, kwargs
            ) as trace:
                (
                    http_version,
                    status,
                    reason_phrase,
                    headers,
                ) = await self._receive_response_headers(**kwargs)
                trace.return_value = (
                    http_version,
                    status,
                    reason_phrase,
                    headers,
                )
    
            return Response(
                status=status,
                headers=headers,
                content=HTTP11ConnectionByteStream(self, request),
                extensions={
                    "http_version": http_version,
                    "reason_phrase": reason_phrase,
                    "network_stream": self._network_stream,
                },
            )
        except BaseException as exc:
            async with Trace("http11.response_closed", request) as trace:
                await self._response_closed()
>           raise exc

../../../.pyenv/versions/3.10.6/envs/taxifare-env/lib/python3.10/site-packages/httpcore/_async/http11.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <AsyncHTTP11Connection ['https://taxifare-5t5qkz7wga-nn.a.run.app:443', CLOSED, Request Count: 1]>
request = <Request [b'GET']>

    async def handle_async_request(self, request: Request) -> Response:
        if not self.can_handle_request(request.url.origin):
            raise RuntimeError(
                f"Attempted to send request to {request.url.origin} on connection "
                f"to {self._origin}"
            )
    
        async with self._state_lock:
            if self._state in (HTTPConnectionState.NEW, HTTPConnectionState.IDLE):
                self._request_count += 1
                self._state = HTTPConnectionState.ACTIVE
                self._expire_at = None
            else:
                raise ConnectionNotAvailable()
    
        try:
            kwargs = {"request": request}
            async with Trace("http11.send_request_headers", request, kwargs) as trace:
                await self._send_request_headers(**kwargs)
            async with Trace("http11.send_request_body", request, kwargs) as trace:
                await self._send_request_body(**kwargs)
            async with Trace(
                "http11.receive_response_headers", request, kwargs
            ) as trace:
                (
                    http_version,
                    status,
                    reason_phrase,
                    headers,
>               ) = await self._receive_response_headers(**kwargs)

../../../.pyenv/versions/3.10.6/envs/taxifare-env/lib/python3.10/site-packages/httpcore/_async/http11.py:95: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <AsyncHTTP11Connection ['https://taxifare-5t5qkz7wga-nn.a.run.app:443', CLOSED, Request Count: 1]>
request = <Request [b'GET']>

    async def _receive_response_headers(
        self, request: Request
    ) -> Tuple[bytes, int, bytes, List[Tuple[bytes, bytes]]]:
        timeouts = request.extensions.get("timeout", {})
        timeout = timeouts.get("read", None)
    
        while True:
>           event = await self._receive_event(timeout=timeout)

../../../.pyenv/versions/3.10.6/envs/taxifare-env/lib/python3.10/site-packages/httpcore/_async/http11.py:159: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <AsyncHTTP11Connection ['https://taxifare-5t5qkz7wga-nn.a.run.app:443', CLOSED, Request Count: 1]>
timeout = 10

    async def _receive_event(
        self, timeout: Optional[float] = None
    ) -> Union[h11.Event, Type[h11.PAUSED]]:
        while True:
            with map_exceptions({h11.RemoteProtocolError: RemoteProtocolError}):
                event = self._h11_state.next_event()
    
            if event is h11.NEED_DATA:
>               data = await self._network_stream.read(
                    self.READ_NUM_BYTES, timeout=timeout
                )

../../../.pyenv/versions/3.10.6/envs/taxifare-env/lib/python3.10/site-packages/httpcore/_async/http11.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <httpcore.backends.asyncio.AsyncIOStream object at 0x128a98e50>
max_bytes = 65536, timeout = 10

    async def read(
        self, max_bytes: int, timeout: typing.Optional[float] = None
    ) -> bytes:
        exc_map = {
            TimeoutError: ReadTimeout,
            anyio.BrokenResourceError: ReadError,
            anyio.ClosedResourceError: ReadError,
        }
>       with map_exceptions(exc_map):

../../../.pyenv/versions/3.10.6/envs/taxifare-env/lib/python3.10/site-packages/httpcore/backends/asyncio.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <contextlib._GeneratorContextManager object at 0x128ad0370>
typ = <class 'TimeoutError'>, value = TimeoutError()
traceback = <traceback object at 0x128af1a00>

    def __exit__(self, typ, value, traceback):
        if typ is None:
            try:
                next(self.gen)
            except StopIteration:
                return False
            else:
                raise RuntimeError("generator didn't stop")
        else:
            if value is None:
                # Need to force instantiation so we can reliably
                # tell if we get the same exception back
                value = typ()
            try:
>               self.gen.throw(typ, value, traceback)

../../../.pyenv/versions/3.10.6/lib/python3.10/contextlib.py:153: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

map = {<class 'TimeoutError'>: <class 'httpcore.ReadTimeout'>, <class 'anyio.BrokenResourceError'>: <class 'httpcore.ReadError'>, <class 'anyio.ClosedResourceError'>: <class 'httpcore.ReadError'>}

    @contextlib.contextmanager
    def map_exceptions(map: ExceptionMapping) -> Iterator[None]:
        try:
            yield
        except Exception as exc:  # noqa: PIE786
            for from_exc, to_exc in map.items():
                if isinstance(exc, from_exc):
>                   raise to_exc(exc)
E                   httpcore.ReadTimeout

../../../.pyenv/versions/3.10.6/envs/taxifare-env/lib/python3.10/site-packages/httpcore/_exceptions.py:14: ReadTimeout

The above exception was the direct cause of the following exception:

    @pytest.mark.asyncio
    async def test_root_is_up():
        async with AsyncClient(base_url=SERVICE_URL, timeout=10) as ac:
>           response = await ac.get("/")

tests/api/test_cloud_endpoints.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../.pyenv/versions/3.10.6/envs/taxifare-env/lib/python3.10/site-packages/httpx/_client.py:1754: in get
    return await self.request(
../../../.pyenv/versions/3.10.6/envs/taxifare-env/lib/python3.10/site-packages/httpx/_client.py:1530: in request
    return await self.send(request, auth=auth, follow_redirects=follow_redirects)
../../../.pyenv/versions/3.10.6/envs/taxifare-env/lib/python3.10/site-packages/httpx/_client.py:1617: in send
    response = await self._send_handling_auth(
../../../.pyenv/versions/3.10.6/envs/taxifare-env/lib/python3.10/site-packages/httpx/_client.py:1645: in _send_handling_auth
    response = await self._send_handling_redirects(
../../../.pyenv/versions/3.10.6/envs/taxifare-env/lib/python3.10/site-packages/httpx/_client.py:1682: in _send_handling_redirects
    response = await self._send_single_request(request)
../../../.pyenv/versions/3.10.6/envs/taxifare-env/lib/python3.10/site-packages/httpx/_client.py:1719: in _send_single_request
    response = await transport.handle_async_request(request)
../../../.pyenv/versions/3.10.6/envs/taxifare-env/lib/python3.10/site-packages/httpx/_transports/default.py:352: in handle_async_request
    with map_httpcore_exceptions():
../../../.pyenv/versions/3.10.6/lib/python3.10/contextlib.py:153: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        try:
            yield
        except Exception as exc:  # noqa: PIE-786
            mapped_exc = None
    
            for from_exc, to_exc in HTTPCORE_EXC_MAP.items():
                if not isinstance(exc, from_exc):
                    continue
                # We want to map to the most specific exception we can find.
                # Eg if `exc` is an `httpcore.ReadTimeout`, we want to map to
                # `httpx.ReadTimeout`, not just `httpx.TimeoutException`.
                if mapped_exc is None or issubclass(to_exc, mapped_exc):
                    mapped_exc = to_exc
    
            if mapped_exc is None:  # pragma: no cover
                raise
    
            message = str(exc)
>           raise mapped_exc(message) from exc
E           httpx.ReadTimeout

../../../.pyenv/versions/3.10.6/envs/taxifare-env/lib/python3.10/site-packages/httpx/_transports/default.py:77: ReadTimeout
=========================== short test summary info ============================
FAILED tests/api/test_cloud_endpoints.py::test_root_is_up - httpx.ReadTimeout
================= 1 failed, 11 passed, 103 warnings in 21.08s ==================
